{"version":3,"file":"static/js/430.d8965369.chunk.js","mappings":"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","sources":["Map.js","../node_modules/leaflet-polylinedecorator/dist/leaflet.polylineDecorator.js"],"sourcesContent":["import React, { useEffect, useRef } from 'react'; \r\nimport './App.css';\r\nimport L from 'leaflet';\r\nimport 'leaflet/dist/leaflet.css';\r\nimport 'leaflet-polylinedecorator';\r\n\r\n\r\n// ייבוא תמונות האייקונים\r\nimport shopIcon from './Icons/shop.jpg';\r\nimport hotelIcon from './Icons/hotel.jpeg';\r\nimport busStationIcon from './Icons/bus_station.png';\r\nimport airplaneIcon from './Icons/airpline.png';\r\n\r\nfunction Map({ hotelsData, businessesData_destination, stationsData_destination, businessesData_origin, stationsData_origin, Destination, Origin }) {\r\n\r\n  const mapRef = useRef(null); // שמירת הפניה למפה\r\n  let groupedLocations = {};\r\n  let markers = [];\r\n\r\n  const BusinessesIcon = L.icon({\r\n    iconUrl: shopIcon,\r\n    iconSize: [32, 32],\r\n    iconAnchor: [16, 32],\r\n    popupAnchor: [0, -28],\r\n  });\r\n\r\n  const HotelsIcon = L.icon({\r\n    iconUrl: hotelIcon,\r\n    iconSize: [32, 32],\r\n    iconAnchor: [16, 32],\r\n    popupAnchor: [0, -28],\r\n  });\r\n\r\n  const StationsIcon = L.icon({\r\n    iconUrl: busStationIcon,\r\n    iconSize: [32, 32],\r\n    iconAnchor: [16, 32],\r\n    popupAnchor: [0, -28],\r\n  });\r\n\r\n  const AirportsIcon = L.icon({\r\n    iconUrl: airplaneIcon,\r\n    iconSize: [32, 32],\r\n    iconAnchor: [16, 32],\r\n    popupAnchor: [0, -28],\r\n  });\r\n\r\n  const initializeMap = () => {\r\n    if (mapRef.current) return; // אם המפה כבר קיימת, לא לאתחל אותה מחדש\r\n\r\n    mapRef.current = L.map('map').setView([20, 0], 2);\r\n    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {\r\n      attribution: '&copy; <a href=\"https://www.openstreetmap.org/copyright\">OpenStreetMap</a> contributors',\r\n    }).addTo(mapRef.current);\r\n\r\n    console.log('Hotels Data:', hotelsData);\r\n    console.log('Businesses Data d:', businessesData_destination);\r\n    console.log('Businesses Data o:', businessesData_origin);\r\n    console.log('Stations Data d:', stationsData_destination);\r\n    console.log('Stations Data o:', stationsData_origin);\r\n    console.log('Destination:', Destination);\r\n    console.log('Origin:', Origin);\r\n\r\n    groupAndAddMarkers();\r\n    drawArrow();\r\n  };\r\n\r\n  const groupAndAddMarkers = () => {\r\n    groupedLocations = {};\r\n\r\n    const allData = [\r\n      { data: hotelsData?.data || [], icon: HotelsIcon },\r\n      { data: businessesData_destination?.businesses || [], icon: BusinessesIcon },\r\n      { data: businessesData_origin?.businesses || [], icon: BusinessesIcon },\r\n      { data: stationsData_destination?.stations || [], icon: StationsIcon },\r\n      { data: stationsData_origin?.stations || [], icon: StationsIcon },\r\n      { data: [Destination] || [], icon: AirportsIcon },\r\n      { data: [Origin] || [], icon: AirportsIcon }\r\n    ];\r\n\r\n    allData.forEach(({ data, icon }) => {\r\n      data.forEach(item => {\r\n        // קבלת קואורדינטות על פי הסוגים השונים של הנתונים\r\n        let latitude = item?.latitude || item.geoCode?.latitude || item.place?.location?.lat || item.coordinates?.latitude;\r\n        let longitude = item?.longitude || item.geoCode?.longitude || item.place?.location?.lng || item.coordinates?.longitude;\r\n\r\n        // אם אין קואורדינטות, נדלג על המיקום\r\n        if (!latitude || !longitude) {\r\n          console.warn(`Missing coordinates for item:`, item);\r\n          return;\r\n        }\r\n\r\n        const key = `${latitude},${longitude}`;\r\n        if (!groupedLocations[key]) {\r\n          groupedLocations[key] = { items: [], icon };\r\n        }\r\n        groupedLocations[key].items.push(item);\r\n      });\r\n    });\r\n\r\n    console.log('Grouped Locations:', groupedLocations);\r\n\r\n    addMarkersToMap();\r\n  };\r\n\r\n  const addMarkersToMap = () => {\r\n    for (const key in groupedLocations) {\r\n      const { items, icon } = groupedLocations[key];\r\n      const firstItem = items[0];\r\n\r\n      // קבלת קואורדינטות ראשוניות מהפריט הראשון\r\n      let latitude = firstItem.latitude || firstItem.coordinates?.latitude || firstItem.geoCode?.latitude || firstItem.place?.location?.lat;\r\n      let longitude = firstItem.longitude || firstItem.coordinates?.longitude || firstItem.geoCode?.longitude || firstItem.place?.location?.lng;\r\n\r\n      // אם אין קואורדינטות תקינות, נדלג על המיקום\r\n      if (!latitude || !longitude) {\r\n        console.warn(`Missing coordinates for item:`, firstItem);\r\n        continue;\r\n      }\r\n\r\n      latitude = parseFloat(latitude);\r\n      longitude = parseFloat(longitude);\r\n\r\n      if (isNaN(latitude) || isNaN(longitude)) {\r\n        console.warn(`Invalid coordinates: ${latitude}, ${longitude}`);\r\n        continue;\r\n      }\r\n\r\n      const popupContent = generatePopupContent(items);\r\n      const marker = L.marker([latitude, longitude], { icon });\r\n\r\n      marker.bindPopup(popupContent, { maxHeight: 400 });\r\n      marker.addTo(mapRef.current);\r\n      markers.push(marker);\r\n    }\r\n  };\r\n\r\n  const generatePopupContent = (items) => {\r\n    let content = '<div class=\"popup-content\">';\r\n    items.forEach(item => {\r\n      content += `<div> ${item.name || item.place.name || 'Unnamed' }</div>`;\r\n    });\r\n    content += '</div>';\r\n    return content;\r\n  };\r\n\r\n\r\n  const drawArrow = () => {\r\n    if (!Origin || !Destination) return;\r\n  \r\n    const originCoords = [Origin.latitude, Origin.longitude];\r\n    const destinationCoords = [Destination.latitude, Destination.longitude];\r\n  \r\n    if (originCoords.includes(undefined) || destinationCoords.includes(undefined)) {\r\n      console.warn('Missing coordinates for Origin or Destination');\r\n      return;\r\n    }\r\n  \r\n    // יצירת הפוליליין\r\n    const polyline = L.polyline([originCoords, destinationCoords], { \r\n      color: 'blue', \r\n      weight: 4, \r\n      opacity: 0.7,\r\n      dashArray: '5, 10',\r\n      lineJoin: 'round'\r\n    }).addTo(mapRef.current);\r\n  \r\n    // הוספת החץ על הפוליליין\r\n    L.polylineDecorator(polyline, {\r\n      patterns: [\r\n        {\r\n          offset: '100%', // מיקום החץ\r\n          repeat: 0, // חץ אחד בלבד\r\n          symbol: L.Symbol.arrowHead({\r\n            pixelSize: 40, // גודל החץ\r\n            polygon: true, // חץ מלא\r\n            pathOptions: { color: 'blue', fillOpacity: 1, weight: 0 }\r\n          })\r\n        }\r\n      ]\r\n    }).addTo(mapRef.current);\r\n  };\r\n\r\n\r\n  useEffect(() => {\r\n    initializeMap();\r\n\r\n    return () => {\r\n      if (mapRef.current) {\r\n        mapRef.current.off();\r\n        mapRef.current.remove();\r\n        mapRef.current = null;\r\n      }\r\n    };\r\n  }, []);\r\n\r\n  return <div id=\"map\" style={{ height: '500px', width: '100%' }}></div>;\r\n}\r\n\r\nexport default Map;\r\n","(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(require('leaflet')) :\n\ttypeof define === 'function' && define.amd ? define(['leaflet'], factory) :\n\t(factory(global.L));\n}(this, (function (L$1) { 'use strict';\n\nL$1 = L$1 && L$1.hasOwnProperty('default') ? L$1['default'] : L$1;\n\n// functional re-impl of L.Point.distanceTo,\n// with no dependency on Leaflet for easier testing\nfunction pointDistance(ptA, ptB) {\n    var x = ptB.x - ptA.x;\n    var y = ptB.y - ptA.y;\n    return Math.sqrt(x * x + y * y);\n}\n\nvar computeSegmentHeading = function computeSegmentHeading(a, b) {\n    return (Math.atan2(b.y - a.y, b.x - a.x) * 180 / Math.PI + 90 + 360) % 360;\n};\n\nvar asRatioToPathLength = function asRatioToPathLength(_ref, totalPathLength) {\n    var value = _ref.value,\n        isInPixels = _ref.isInPixels;\n    return isInPixels ? value / totalPathLength : value;\n};\n\nfunction parseRelativeOrAbsoluteValue(value) {\n    if (typeof value === 'string' && value.indexOf('%') !== -1) {\n        return {\n            value: parseFloat(value) / 100,\n            isInPixels: false\n        };\n    }\n    var parsedValue = value ? parseFloat(value) : 0;\n    return {\n        value: parsedValue,\n        isInPixels: parsedValue > 0\n    };\n}\n\nvar pointsEqual = function pointsEqual(a, b) {\n    return a.x === b.x && a.y === b.y;\n};\n\nfunction pointsToSegments(pts) {\n    return pts.reduce(function (segments, b, idx, points) {\n        // this test skips same adjacent points\n        if (idx > 0 && !pointsEqual(b, points[idx - 1])) {\n            var a = points[idx - 1];\n            var distA = segments.length > 0 ? segments[segments.length - 1].distB : 0;\n            var distAB = pointDistance(a, b);\n            segments.push({\n                a: a,\n                b: b,\n                distA: distA,\n                distB: distA + distAB,\n                heading: computeSegmentHeading(a, b)\n            });\n        }\n        return segments;\n    }, []);\n}\n\nfunction projectPatternOnPointPath(pts, pattern) {\n    // 1. split the path into segment infos\n    var segments = pointsToSegments(pts);\n    var nbSegments = segments.length;\n    if (nbSegments === 0) {\n        return [];\n    }\n\n    var totalPathLength = segments[nbSegments - 1].distB;\n\n    var offset = asRatioToPathLength(pattern.offset, totalPathLength);\n    var endOffset = asRatioToPathLength(pattern.endOffset, totalPathLength);\n    var repeat = asRatioToPathLength(pattern.repeat, totalPathLength);\n\n    var repeatIntervalPixels = totalPathLength * repeat;\n    var startOffsetPixels = offset > 0 ? totalPathLength * offset : 0;\n    var endOffsetPixels = endOffset > 0 ? totalPathLength * endOffset : 0;\n\n    // 2. generate the positions of the pattern as offsets from the path start\n    var positionOffsets = [];\n    var positionOffset = startOffsetPixels;\n    do {\n        positionOffsets.push(positionOffset);\n        positionOffset += repeatIntervalPixels;\n    } while (repeatIntervalPixels > 0 && positionOffset < totalPathLength - endOffsetPixels);\n\n    // 3. projects offsets to segments\n    var segmentIndex = 0;\n    var segment = segments[0];\n    return positionOffsets.map(function (positionOffset) {\n        // find the segment matching the offset,\n        // starting from the previous one as offsets are ordered\n        while (positionOffset > segment.distB && segmentIndex < nbSegments - 1) {\n            segmentIndex++;\n            segment = segments[segmentIndex];\n        }\n\n        var segmentRatio = (positionOffset - segment.distA) / (segment.distB - segment.distA);\n        return {\n            pt: interpolateBetweenPoints(segment.a, segment.b, segmentRatio),\n            heading: segment.heading\n        };\n    });\n}\n\n/**\n* Finds the point which lies on the segment defined by points A and B,\n* at the given ratio of the distance from A to B, by linear interpolation.\n*/\nfunction interpolateBetweenPoints(ptA, ptB, ratio) {\n    if (ptB.x !== ptA.x) {\n        return {\n            x: ptA.x + ratio * (ptB.x - ptA.x),\n            y: ptA.y + ratio * (ptB.y - ptA.y)\n        };\n    }\n    // special case where points lie on the same vertical axis\n    return {\n        x: ptA.x,\n        y: ptA.y + (ptB.y - ptA.y) * ratio\n    };\n}\n\n(function() {\r\n    // save these original methods before they are overwritten\r\n    var proto_initIcon = L.Marker.prototype._initIcon;\r\n    var proto_setPos = L.Marker.prototype._setPos;\r\n\r\n    var oldIE = (L.DomUtil.TRANSFORM === 'msTransform');\r\n\r\n    L.Marker.addInitHook(function () {\r\n        var iconOptions = this.options.icon && this.options.icon.options;\r\n        var iconAnchor = iconOptions && this.options.icon.options.iconAnchor;\r\n        if (iconAnchor) {\r\n            iconAnchor = (iconAnchor[0] + 'px ' + iconAnchor[1] + 'px');\r\n        }\r\n        this.options.rotationOrigin = this.options.rotationOrigin || iconAnchor || 'center bottom' ;\r\n        this.options.rotationAngle = this.options.rotationAngle || 0;\r\n\r\n        // Ensure marker keeps rotated during dragging\r\n        this.on('drag', function(e) { e.target._applyRotation(); });\r\n    });\r\n\r\n    L.Marker.include({\r\n        _initIcon: function() {\r\n            proto_initIcon.call(this);\r\n        },\r\n\r\n        _setPos: function (pos) {\r\n            proto_setPos.call(this, pos);\r\n            this._applyRotation();\r\n        },\r\n\r\n        _applyRotation: function () {\r\n            if(this.options.rotationAngle) {\r\n                this._icon.style[L.DomUtil.TRANSFORM+'Origin'] = this.options.rotationOrigin;\r\n\r\n                if(oldIE) {\r\n                    // for IE 9, use the 2D rotation\r\n                    this._icon.style[L.DomUtil.TRANSFORM] = 'rotate(' + this.options.rotationAngle + 'deg)';\r\n                } else {\r\n                    // for modern browsers, prefer the 3D accelerated version\r\n                    this._icon.style[L.DomUtil.TRANSFORM] += ' rotateZ(' + this.options.rotationAngle + 'deg)';\r\n                }\r\n            }\r\n        },\r\n\r\n        setRotationAngle: function(angle) {\r\n            this.options.rotationAngle = angle;\r\n            this.update();\r\n            return this;\r\n        },\r\n\r\n        setRotationOrigin: function(origin) {\r\n            this.options.rotationOrigin = origin;\r\n            this.update();\r\n            return this;\r\n        }\r\n    });\r\n})();\n\nL$1.Symbol = L$1.Symbol || {};\n\n/**\n* A simple dash symbol, drawn as a Polyline.\n* Can also be used for dots, if 'pixelSize' option is given the 0 value.\n*/\nL$1.Symbol.Dash = L$1.Class.extend({\n    options: {\n        pixelSize: 10,\n        pathOptions: {}\n    },\n\n    initialize: function initialize(options) {\n        L$1.Util.setOptions(this, options);\n        this.options.pathOptions.clickable = false;\n    },\n\n    buildSymbol: function buildSymbol(dirPoint, latLngs, map, index, total) {\n        var opts = this.options;\n        var d2r = Math.PI / 180;\n\n        // for a dot, nothing more to compute\n        if (opts.pixelSize <= 1) {\n            return L$1.polyline([dirPoint.latLng, dirPoint.latLng], opts.pathOptions);\n        }\n\n        var midPoint = map.project(dirPoint.latLng);\n        var angle = -(dirPoint.heading - 90) * d2r;\n        var a = L$1.point(midPoint.x + opts.pixelSize * Math.cos(angle + Math.PI) / 2, midPoint.y + opts.pixelSize * Math.sin(angle) / 2);\n        // compute second point by central symmetry to avoid unecessary cos/sin\n        var b = midPoint.add(midPoint.subtract(a));\n        return L$1.polyline([map.unproject(a), map.unproject(b)], opts.pathOptions);\n    }\n});\n\nL$1.Symbol.dash = function (options) {\n    return new L$1.Symbol.Dash(options);\n};\n\nL$1.Symbol.ArrowHead = L$1.Class.extend({\n    options: {\n        polygon: true,\n        pixelSize: 10,\n        headAngle: 60,\n        pathOptions: {\n            stroke: false,\n            weight: 2\n        }\n    },\n\n    initialize: function initialize(options) {\n        L$1.Util.setOptions(this, options);\n        this.options.pathOptions.clickable = false;\n    },\n\n    buildSymbol: function buildSymbol(dirPoint, latLngs, map, index, total) {\n        return this.options.polygon ? L$1.polygon(this._buildArrowPath(dirPoint, map), this.options.pathOptions) : L$1.polyline(this._buildArrowPath(dirPoint, map), this.options.pathOptions);\n    },\n\n    _buildArrowPath: function _buildArrowPath(dirPoint, map) {\n        var d2r = Math.PI / 180;\n        var tipPoint = map.project(dirPoint.latLng);\n        var direction = -(dirPoint.heading - 90) * d2r;\n        var radianArrowAngle = this.options.headAngle / 2 * d2r;\n\n        var headAngle1 = direction + radianArrowAngle;\n        var headAngle2 = direction - radianArrowAngle;\n        var arrowHead1 = L$1.point(tipPoint.x - this.options.pixelSize * Math.cos(headAngle1), tipPoint.y + this.options.pixelSize * Math.sin(headAngle1));\n        var arrowHead2 = L$1.point(tipPoint.x - this.options.pixelSize * Math.cos(headAngle2), tipPoint.y + this.options.pixelSize * Math.sin(headAngle2));\n\n        return [map.unproject(arrowHead1), dirPoint.latLng, map.unproject(arrowHead2)];\n    }\n});\n\nL$1.Symbol.arrowHead = function (options) {\n    return new L$1.Symbol.ArrowHead(options);\n};\n\nL$1.Symbol.Marker = L$1.Class.extend({\n    options: {\n        markerOptions: {},\n        rotate: false\n    },\n\n    initialize: function initialize(options) {\n        L$1.Util.setOptions(this, options);\n        this.options.markerOptions.clickable = false;\n        this.options.markerOptions.draggable = false;\n    },\n\n    buildSymbol: function buildSymbol(directionPoint, latLngs, map, index, total) {\n        if (this.options.rotate) {\n            this.options.markerOptions.rotationAngle = directionPoint.heading + (this.options.angleCorrection || 0);\n        }\n        return L$1.marker(directionPoint.latLng, this.options.markerOptions);\n    }\n});\n\nL$1.Symbol.marker = function (options) {\n    return new L$1.Symbol.Marker(options);\n};\n\nvar isCoord = function isCoord(c) {\n    return c instanceof L$1.LatLng || Array.isArray(c) && c.length === 2 && typeof c[0] === 'number';\n};\n\nvar isCoordArray = function isCoordArray(ll) {\n    return Array.isArray(ll) && isCoord(ll[0]);\n};\n\nL$1.PolylineDecorator = L$1.FeatureGroup.extend({\n    options: {\n        patterns: []\n    },\n\n    initialize: function initialize(paths, options) {\n        L$1.FeatureGroup.prototype.initialize.call(this);\n        L$1.Util.setOptions(this, options);\n        this._map = null;\n        this._paths = this._initPaths(paths);\n        this._bounds = this._initBounds();\n        this._patterns = this._initPatterns(this.options.patterns);\n    },\n\n    /**\n    * Deals with all the different cases. input can be one of these types:\n    * array of LatLng, array of 2-number arrays, Polyline, Polygon,\n    * array of one of the previous.\n    */\n    _initPaths: function _initPaths(input, isPolygon) {\n        var _this = this;\n\n        if (isCoordArray(input)) {\n            // Leaflet Polygons don't need the first point to be repeated, but we do\n            var coords = isPolygon ? input.concat([input[0]]) : input;\n            return [coords];\n        }\n        if (input instanceof L$1.Polyline) {\n            // we need some recursivity to support multi-poly*\n            return this._initPaths(input.getLatLngs(), input instanceof L$1.Polygon);\n        }\n        if (Array.isArray(input)) {\n            // flatten everything, we just need coordinate lists to apply patterns\n            return input.reduce(function (flatArray, p) {\n                return flatArray.concat(_this._initPaths(p, isPolygon));\n            }, []);\n        }\n        return [];\n    },\n\n    // parse pattern definitions and precompute some values\n    _initPatterns: function _initPatterns(patternDefs) {\n        return patternDefs.map(this._parsePatternDef);\n    },\n\n    /**\n    * Changes the patterns used by this decorator\n    * and redraws the new one.\n    */\n    setPatterns: function setPatterns(patterns) {\n        this.options.patterns = patterns;\n        this._patterns = this._initPatterns(this.options.patterns);\n        this.redraw();\n    },\n\n    /**\n    * Changes the patterns used by this decorator\n    * and redraws the new one.\n    */\n    setPaths: function setPaths(paths) {\n        this._paths = this._initPaths(paths);\n        this._bounds = this._initBounds();\n        this.redraw();\n    },\n\n    /**\n    * Parse the pattern definition\n    */\n    _parsePatternDef: function _parsePatternDef(patternDef, latLngs) {\n        return {\n            symbolFactory: patternDef.symbol,\n            // Parse offset and repeat values, managing the two cases:\n            // absolute (in pixels) or relative (in percentage of the polyline length)\n            offset: parseRelativeOrAbsoluteValue(patternDef.offset),\n            endOffset: parseRelativeOrAbsoluteValue(patternDef.endOffset),\n            repeat: parseRelativeOrAbsoluteValue(patternDef.repeat)\n        };\n    },\n\n    onAdd: function onAdd(map) {\n        this._map = map;\n        this._draw();\n        this._map.on('moveend', this.redraw, this);\n    },\n\n    onRemove: function onRemove(map) {\n        this._map.off('moveend', this.redraw, this);\n        this._map = null;\n        L$1.FeatureGroup.prototype.onRemove.call(this, map);\n    },\n\n    /**\n    * As real pattern bounds depends on map zoom and bounds,\n    * we just compute the total bounds of all paths decorated by this instance.\n    */\n    _initBounds: function _initBounds() {\n        var allPathCoords = this._paths.reduce(function (acc, path) {\n            return acc.concat(path);\n        }, []);\n        return L$1.latLngBounds(allPathCoords);\n    },\n\n    getBounds: function getBounds() {\n        return this._bounds;\n    },\n\n    /**\n    * Returns an array of ILayers object\n    */\n    _buildSymbols: function _buildSymbols(latLngs, symbolFactory, directionPoints) {\n        var _this2 = this;\n\n        return directionPoints.map(function (directionPoint, i) {\n            return symbolFactory.buildSymbol(directionPoint, latLngs, _this2._map, i, directionPoints.length);\n        });\n    },\n\n    /**\n    * Compute pairs of LatLng and heading angle,\n    * that define positions and directions of the symbols on the path\n    */\n    _getDirectionPoints: function _getDirectionPoints(latLngs, pattern) {\n        var _this3 = this;\n\n        if (latLngs.length < 2) {\n            return [];\n        }\n        var pathAsPoints = latLngs.map(function (latLng) {\n            return _this3._map.project(latLng);\n        });\n        return projectPatternOnPointPath(pathAsPoints, pattern).map(function (point) {\n            return {\n                latLng: _this3._map.unproject(L$1.point(point.pt)),\n                heading: point.heading\n            };\n        });\n    },\n\n    redraw: function redraw() {\n        if (!this._map) {\n            return;\n        }\n        this.clearLayers();\n        this._draw();\n    },\n\n    /**\n    * Returns all symbols for a given pattern as an array of FeatureGroup\n    */\n    _getPatternLayers: function _getPatternLayers(pattern) {\n        var _this4 = this;\n\n        var mapBounds = this._map.getBounds().pad(0.1);\n        return this._paths.map(function (path) {\n            var directionPoints = _this4._getDirectionPoints(path, pattern)\n            // filter out invisible points\n            .filter(function (point) {\n                return mapBounds.contains(point.latLng);\n            });\n            return L$1.featureGroup(_this4._buildSymbols(path, pattern.symbolFactory, directionPoints));\n        });\n    },\n\n    /**\n    * Draw all patterns\n    */\n    _draw: function _draw() {\n        var _this5 = this;\n\n        this._patterns.map(function (pattern) {\n            return _this5._getPatternLayers(pattern);\n        }).forEach(function (layers) {\n            _this5.addLayer(L$1.featureGroup(layers));\n        });\n    }\n});\n/*\n * Allows compact syntax to be used\n */\nL$1.polylineDecorator = function (paths, options) {\n    return new L$1.PolylineDecorator(paths, options);\n};\n\n})));\n"],"names":["_ref","hotelsData","businessesData_destination","stationsData_destination","businessesData_origin","stationsData_origin","Destination","Origin","mapRef","useRef","groupedLocations","markers","BusinessesIcon","L","iconUrl","iconSize","iconAnchor","popupAnchor","HotelsIcon","hotelIcon","StationsIcon","AirportsIcon","groupAndAddMarkers","data","icon","businesses","stations","forEach","_ref2","item","_item$geoCode","_item$place","_item$place$location","_item$coordinates","_item$geoCode2","_item$place2","_item$place2$location","_item$coordinates2","latitude","geoCode","place","location","lat","coordinates","longitude","lng","console","warn","key","concat","items","push","log","addMarkersToMap","_firstItem$coordinate","_firstItem$geoCode","_firstItem$place","_firstItem$place$loca","_firstItem$coordinate2","_firstItem$geoCode2","_firstItem$place2","_firstItem$place2$loc","firstItem","parseFloat","isNaN","popupContent","generatePopupContent","marker","bindPopup","maxHeight","addTo","current","content","name","drawArrow","originCoords","destinationCoords","includes","undefined","polyline","color","weight","opacity","dashArray","lineJoin","patterns","offset","repeat","symbol","arrowHead","pixelSize","polygon","pathOptions","fillOpacity","useEffect","setView","attribution","off","remove","_jsx","id","style","height","width","L$1","pointDistance","ptA","ptB","x","y","Math","sqrt","hasOwnProperty","computeSegmentHeading","a","b","atan2","PI","asRatioToPathLength","totalPathLength","value","isInPixels","parseRelativeOrAbsoluteValue","indexOf","parsedValue","pointsEqual","pointsToSegments","pts","reduce","segments","idx","points","distA","length","distB","distAB","heading","projectPatternOnPointPath","pattern","nbSegments","endOffset","repeatIntervalPixels","endOffsetPixels","positionOffsets","positionOffset","segmentIndex","segment","map","segmentRatio","pt","interpolateBetweenPoints","ratio","proto_initIcon","Marker","prototype","_initIcon","proto_setPos","_setPos","oldIE","DomUtil","TRANSFORM","addInitHook","this","options","rotationOrigin","rotationAngle","on","e","target","_applyRotation","include","call","pos","_icon","setRotationAngle","angle","update","setRotationOrigin","origin","Symbol","Dash","Class","extend","initialize","Util","setOptions","clickable","buildSymbol","dirPoint","latLngs","index","total","opts","d2r","latLng","midPoint","project","point","cos","sin","add","subtract","unproject","dash","ArrowHead","headAngle","stroke","_buildArrowPath","tipPoint","direction","radianArrowAngle","headAngle1","headAngle2","arrowHead1","arrowHead2","markerOptions","rotate","draggable","directionPoint","angleCorrection","isCoord","c","LatLng","Array","isArray","isCoordArray","ll","PolylineDecorator","FeatureGroup","paths","_map","_paths","_initPaths","_bounds","_initBounds","_patterns","_initPatterns","input","isPolygon","_this","Polyline","getLatLngs","Polygon","flatArray","p","patternDefs","_parsePatternDef","setPatterns","redraw","setPaths","patternDef","symbolFactory","onAdd","_draw","onRemove","allPathCoords","acc","path","latLngBounds","getBounds","_buildSymbols","directionPoints","_this2","i","_getDirectionPoints","_this3","clearLayers","_getPatternLayers","_this4","mapBounds","pad","filter","contains","featureGroup","_this5","layers","addLayer","polylineDecorator","factory","require"],"sourceRoot":""}